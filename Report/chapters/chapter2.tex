\chapter{Logic Design}
    \unsure{Chapter sections are subject to change in name and order}
    
    This chapter aims to introduce the reader to the basics of logic design, which will be imperative to the understanding the subsequent chapters. The general structure of this chapter will be based on Appendix A in \cite{riscVbook}. 
    
    We will begin in section \ref{section:Boolean_algebra} by introducing the fundamental algebra and the physical building blocks, used to implement the algebra, such as the OR gate. 
    
    Hereafter we will be using these building blocks to design and create the core components used in the RISC-V architecture such as the decoder and multiplexer in section \ref{section:Combinational_logic}. 

    \section{Boolean algebra}\label{section:Boolean_algebra}
    
        The fundamental tool used in logic design is a branch of mathematical logic called Boolean algebra. Compared to elementary algebra, where we deal with variables which represents some real or complex number, in Boolean algebra the variables are viewed as statements or propositions which is either \textit{true} or \textit{false}.
        
        In addition to the variables in elementary algebra we also had a means of manipulating them. These manipulations are called operations which operates on the variables (operands) where the basic operators of algebra consists of $+$, $-$, $\cross$ and $\divisionsymbol$.
        
        In Boolean algebra we have a distinction between operators which work on one operand and the ones that work on to two operands. These are called unary and binary operators respectively. We would go through a description of these in the following section. 
        
        \subsection{Unary operators}\improvement{make ven diagrams to show the operator function}
            With a single binary operand p we have 2 possible input $true$ and $false$. All output combinations are summarized in table \ref{LogicTable:unary}. Each numbered column here represents an unnamed operator. We will go ahead and describe one of these in the following. The rest can referred to in appendix \ref{appendix:Unary_Operators}. 
            
            \begin{table}[h!]
                \centering
                \begin{tabular}{|c||c|c|c|c|}
                	\hline
                	  $p$   &   1    &    2    &    3    & 4       \\ \hline
                	$true$  & $true$ & $true$  & $false$ & $false$ \\ \hline
                	$false$ & $true$ & $false$ & $true$  & $false$ \\ \hline
                \end{tabular}
                \caption{Logic table of possible unary operators. Each numbered column represents an undefined operator.}
                \label{LogicTable:unary}
            \end{table} 
        
            \subsubsection{Logical complement}
            
                For our first basic Boolean operator we have the logical complement operator, which is represented by NOT, !, $\neg$ or $\bar{x}$ in various literature and commonly referred to as the negation operator. 
                
                The negation operator inverts an operand such that $\neg true = false$ and $\neg false = true$.
                Using a table we can neatly represent the complete function of the negation operator. These tables are called \textit{logic tables}.
                
                A logic table has been created for the negation operator as can be seen in table \ref{LogicTable:Negation}.  The first column represents our proposition and all its possible arguments $true$ and $false$. The second column is then the negated proposition.
                
                \begin{table}[h!]
                    \centering
                    \begin{tabular}{|c|c|}
                    	\hline
                    	  $p$   & $\neg{p}$ \\ \hline
                    	$true$  &  $false$  \\ \hline
                    	$false$ &  $true$   \\ \hline
                    \end{tabular}
                    \caption{Logic table of the negation operator where the proposition p, which is either true or false, can be found in the first column. In the second column we find $\neg p$, which is read as NOT $p$, and its return values.}
                    \label{LogicTable:Negation}
                \end{table}
            
            \subsubsection{Summary}
                
                We can now go ahead and fill the numbered columns table \ref{LogicTable:unary} with the corresponding operators which we have defined throughout this section and appendix \ref{appendix:Unary_Operators}. The filled table can be found in table \ref{LogicTable:unaryfilled}. \improvement{rewrite this section.}
                
                \begin{table}[h!]
                    \centering
                    \begin{tabular}{|c||c|c|c|c|}
                    	\hline
                    	  $p$   & $T(p)$ & $I(p)$  & $\neg p$ & $F(p)$  \\ \hline
                    	$true$  & $true$ & $true$  & $false$  & $false$ \\ \hline
                    	$false$ & $true$ & $false$ &  $true$  & $false$ \\ \hline
                    \end{tabular}
                    \caption{Logic table of possible unary operators where $p$ is our proposition. Column 2-5 shows the output of the corresponding operator.}
                    \label{LogicTable:unaryfilled}
                \end{table} 
                
                 
\newpage        
        \subsection{Binary operators and disjunctive normal form}
        
            With two binary operands, $p$ and $q$, there exist four possible combinations between their respectable values namely $(true, true)$, $(true, false)$, $(false, true)$, $(false, false)$.
            
            Compared to the previous section we now have 4 possible input values for our yet unnamed operators $X(p, q)$. There exist 16 unique sets of outputs and therefore 16 possible operators. An example of a set of outputs could be 
            \begin{equation}
                X(p, q) =\{true, false, false, false\}
            \end{equation}
            where $(p, q) = \{(true, true), (true, false), (false, true), (false, false)\}$ is the set of possible inputs. 
            
            All output sets are summarized in table \ref{LogicTable:PossibleOperators} where each numbered column represents an unnamed operator. 
            
            We will in this section start by defining the basic operators from which we will derive the rest. For brevity we will only go through the 6 most commonly used operators, the rest can be referred to in appendix \ref{appendix:Binaray_Operators}.  
            
            The choice of basic operators is arbitrary but I have chosen the operators for which it is the easiest to derive all other operators, since there exists a method to convert any truth table into a Boolean expression using these which we will get into later.
             
            
            \begin{table}[h!]
                \centering
                \begin{tabular}{|c|c||c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
                	\hline
                	$p$ & $q$ &  1  &  2  &  3  &  4  &  5  &  6  &  7  &  8  &  9  & 10  & 11  & 12  & 13  & 14  & 15  & 16  \\ \hline
                	$t$ & $t$ & $t$ & $t$ & $t$ & $t$ & $f$ & $t$ & $f$ & $f$ & $t$ & $t$ & $f$ & $t$ & $f$ & $f$ & $f$ & $f$ \\ \hline
                	$t$ & $f$ & $t$ & $t$ & $t$ & $f$ & $t$ & $t$ & $t$ & $f$ & $f$ & $f$ & $t$ & $f$ & $t$ & $f$ & $f$ & $f$ \\ \hline
                	$f$ & $t$ & $t$ & $t$ & $f$ & $t$ & $t$ & $f$ & $t$ & $t$ & $f$ & $t$ & $f$ & $f$ & $f$ & $t$ & $f$ & $f$ \\ \hline
                	$f$ & $f$ & $t$ & $f$ & $t$ & $t$ & $t$ & $f$ & $f$ & $t$ & $t$ & $f$ & $t$ & $f$ & $f$ & $f$ & $t$ & $f$ \\ \hline
                \end{tabular} 
                \caption{Logic table of possible binary operators where $t=true$ and $f=false$. Each numbered column represents an unnamed operator.}
                \label{LogicTable:PossibleOperators}
            \end{table}
        
            \subsubsection{Logical conjunction}
        
                The logical conjunction operator is represented by $\wedge$ in mathematics; AND, \&, \&\& in computer science and a $\cdot$ in electronic engineering and commonly referred to as the AND operator or the logical product\improvement{remember to tell why this is later}. The AND operator only results in a true value if both of the operands are true.
                
                Using table \ref{LogicTable:PossibleOperators} we see that the set of outputs which corresponds to this definition is column 12 and is summarized in table \ref{LogicTable:AND}. 
                
                Here we have the propositions $p$ and $q$ in the first two columns and all possible permutations between them in the following rows. The last column then shows the resulting value after doing the AND operation between $p$ and $q$. 
                
                \begin{table}[h!]
                    \centering
                    \begin{tabular}{|c|c|c|}
                    	\hline
                    	  $p$   &   $q$   & $p \wedge q$ \\ \hline
                    	$true$  & $true$  &    $true$    \\ \hline
                    	$true$  & $false$ &   $false$    \\ \hline
                    	$false$ & $true$  &   $false$    \\ \hline
                    	$false$ & $false$ &   $false$    \\ \hline
                    \end{tabular}
                    \caption{Logic table of the AND operator where $p$ is the first proposition and $q$ is the second. All possible permutations are then specified in each row for each proposition. The third column then shows the resulting value of the AND operation between $p$ and $q$.}
                    \label{LogicTable:AND}
                \end{table}
            
            \subsubsection{Logical disjunction}
            
                The logical disjunction operator is represented by $\vee$ in mathematics; OR, $\vert$, $\vert \vert$  in computer science and a $+$ in electronic engineering and commonly referred to as the OR operator or the logical sum\improvement{remember to tell why this is later}. The OR operator results in a true value if one or more of the operands are true.
                
                Using table \ref{LogicTable:PossibleOperators} we see that the set of outputs which corresponds to this definition is column 2 and is summarized in table \ref{LogicTable:OR}. 
                
                Here we have the propositions $p$ and $q$ in the first two columns and all possible permutations between them in the following rows. The last column then shows the resulting value after doing the OR operation between $p$ and $q$.
                
                \begin{table}[h!]
                    \centering
                    \begin{tabular}{|c|c|c|}
                    	\hline
                    	  $p$   &   $q$   & $p \vee q$ \\ \hline
                    	$true$  & $true$  &   $true$   \\ \hline
                    	$true$  & $false$ &   $true$   \\ \hline
                    	$false$ & $true$  &   $true$   \\ \hline
                    	$false$ & $false$ &  $false$   \\ \hline
                    \end{tabular}
                    \caption{Logic table of the OR operator where $p$ is the first proposition and $q$ is the second. All possible permutations are then specified in each row for each proposition. The third column then shows the resulting value of the OR operation between $p$ and $q$.}
                    \label{LogicTable:OR}
                \end{table}
            
                We choose AND, OR and NOT to form our basic or primitive operators from which we will derive all remaining operators.
                
            \subsubsection{Exclusive disjunction and disjunctive normal form}
                
                The exclusive disjunction is represented by $\veebar$ in mathematics or XOR, \textsuperscript{$\wedge$} in computer science and commonly referred to as the XOR or exclusive OR operator. The XOR operator results in a true value only if the operands differ.
                
                Using table \ref{LogicTable:PossibleOperators} we see that the set of outputs which corresponds to this definition is column 7 and is summarized in table \ref{LogicTable:XOR}.
                
                Here we have the propositions $p$ and $q$ in the first two columns and all possible permutations between them in the following rows. The last column then shows the resulting value after doing the XOR operation between $p$ and $q$.
                
                \begin{table}[h!]
                    \centering
                    \begin{tabular}{|c|c|c|}
                    	\hline
                    	  $p$   &   $q$   & $p \veebar q$ \\ \hline
                    	$true$  & $true$  &    $false$    \\ \hline
                    	$true$  & $false$ &    $true$     \\ \hline
                    	$false$ & $true$  &    $true$     \\ \hline
                    	$false$ & $false$ &    $false$    \\ \hline
                    \end{tabular}
                    \caption{Logic table of the XOR operator where $p$ is the first proposition and $q$ is the second. All possible permutations are then specified in each row for each proposition. The third column then shows the resulting value of the XOR operation between $p$ and $q$.}
                    \label{LogicTable:XOR}
                \end{table}
            
                We can define this operator in disjunctive normal \improvement{give a definition of disjunctive normal form} form using our basic operators AND, OR and NOT. 
                
                To do this we first identify all true output in \ref{LogicTable:XOR} namely row 3 and 4. We then take a look at the corresponding input values
                \begin{equation}
                    (p,q) = (true, false) \quad \text{and} \quad (p,q) = (false, true)
                \end{equation}
                and applying the NOT operator on all the false values. We now have the two tuples
                \begin{equation}
                    (p,\neg q) = (true, \neg false) \quad \text{and} \quad (\neg p, q) = (\neg false, true).
                \end{equation}
                
                Hereafter we apply the AND operator between the values in each tuple of input such that
                \begin{equation}
                    p \wedge \neg q = true \wedge \neg false \quad \text{and} \quad \neg p \wedge q = false \wedge \neg true.
                \end{equation}
                Lastly we apply the OR operators between each tuple and we have the final expression for XOR in terms of the basic operators
                \begin{equation}
                    p \veebar q = (p \wedge \neg q) \vee (\neg p \wedge q).
                \end{equation}
                
                The procedure is summarized as follows
                \begin{enumerate}
                    \item Find all output values, which are true.
                    \item Negate all false input for corresponding true output value.
                    \item Apply AND operator between each value in each input tuple.
                    \item Lastly apply OR operator between each input tuple.
                \end{enumerate}
                Using this procedure any logic table can be expressed as a Boolean expression and will be used extensively throughout this thesis.
                
                
            \subsubsection{Summary}
                We can now go ahead and fill the numbered columns table \ref{LogicTable:PossibleOperators} with the corresponding operators which we have defined throughout this section. The filled table can be found in table \ref{LogicTable:BinaryOperators}. \improvement{rewrite this section.}
                
                \begin{table}[h!]
                    \centering
                    \begin{tabular}{|c|c||c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
                    	\hline
                    	$p$ & $q$ & $\top$ & $\vee$ & $\leftarrow$ & $\rightarrow$ & $\uparrow$ & $P(p,q)$ & $\veebar$ & $\neg P(p,q)$ & $\leftrightarrow$ & $Q(p, q)$ & $\neg Q(p,q)$ & $\wedge$ & $\not\rightarrow$ & $\not\leftarrow$ & $\downarrow$ & $\bot$ \\ \hline
                    	$t$ & $t$ &  $t$   &  $t$   &     $t$      &      $t$      &    $f$     &   $t$    &    $f$    &      $f$      &        $t$        &    $t$    &      $f$      &   $t$    &        $f$        &       $f$        &     $f$      &  $f$   \\ \hline
                    	$t$ & $f$ &  $t$   &  $t$   &     $t$      &      $f$      &    $t$     &   $t$    &    $t$    &      $f$      &        $f$        &    $f$    &      $t$      &   $f$    &        $t$        &       $f$        &     $f$      &  $f$   \\ \hline
                    	$f$ & $t$ &  $t$   &  $t$   &     $f$      &      $t$      &    $t$     &   $f$    &    $t$    &      $t$      &        $f$        &    $t$    &      $f$      &   $f$    &        $f$        &       $t$        &     $f$      &  $f$   \\ \hline
                    	$f$ & $f$ &  $t$   &  $f$   &     $t$      &      $t$      &    $t$     &   $f$    &    $f$    &      $t$      &        $t$        &    $f$    &      $t$      &   $f$    &        $f$        &       $f$        &     $t$      &  $f$   \\ \hline
                    \end{tabular} 
                    \caption{Logic table of binary operators where $t=true$ and $f=false$.} 
                    \label{LogicTable:BinaryOperators}
                \end{table}
        
        \subsection{Boolean equations}
            In the last section we saw that it was possible to describe any logic table in terms of the AND, OR and Negation operators. An example of this could be the following
            
            \begin{equation}
                \label{booleanexample}
                p \veebar q = (p \wedge \neg q) \vee (\neg p \wedge q)
            \end{equation}
            where $p$ and $q$ was our propositions. Expression \ref{booleanexample} is an example of a \textit{Boolean equation}. 
            
            Like ordinary algebra, Boolean equations satisfy many of the same basic laws of algebra as summarized in table \ref{Table:Algebralaws}. Here we see that the laws are exactly equivalent to the version we see with ordinary addition and multiplication, hence the names logical sum $\vee$ and logical product $\wedge$.
            
            Using these laws we can drastically simplify complex expressions which we will use later to greatly reduce the complexity of logic units. 
            
            Say we have 
            
            \begin{equation}
               \label{simplify}
                C = A \cdot \bar{B} \cdot \bar{S} + A \cdot B \cdot \bar{S} + \bar{A} \cdot B \cdot S
                  + A \cdot B \cdot S
            \end{equation}
            where A, B, C and S are Boolean variables. Notice that $\cdot = \wedge$ and $+ = \vee$, we use this notation since it is much easier to discern the individual terms. Now we can use the distributivity law we found in table \ref{Table:Algebralaws} to pull $A\cdot \bar{S}$ and $B \cdot S$ outside the parentheses
            
            \begin{equation}
                C = (\bar{B} + B) \cdot A\cdot \bar{S} + (\bar{A} + A)\cdot B\cdot S.
            \end{equation}
            
            Lastly we use the complement law in table \ref{Table:Booleanlaws} ($\bar{B} + B = 1$ and $\bar{A} + A = 1$) and the identity law in table \ref{Table:Algebralaws} ($1 \cdot A\cdot \bar{S} = A\cdot \bar{S}$ and $1 \cdot B\cdot S = B\cdot S$) to simplify such that we have
            
            \begin{equation}
                \label{simplify2}
                C = A\cdot \bar{S} + B\cdot S.
            \end{equation}
            
            Notice that we went from using $11$ operations in (\ref{simplify}) to $3$ in (\ref{simplify2}) by using the Boolean laws to manipulate the equations. Incidentally (\ref{simplify}) is an example of a multiplexer which we will get into later.
              
            
            \begin{table}[h!]
                \centering
                \begin{tabular}{|c|c|c|}
                	\hline
                	     Law       &                     Law of $\vee$                      &                 law of $\wedge$                 \\ \hline
                	Commutativity  &                 $p \vee q = q \vee p$                  &            $p \wedge q = q \wedge p$            \\ \hline
                	Associativity  &        $p \vee (q \vee r) = (p \vee q) \vee r$         & $p \wedge (q \wedge r) = (p \wedge q) \wedge r$ \\ \hline
                	Distributivity & $p \wedge (q \vee r) = (p \wedge q) \vee (p \wedge r)$ &                                                 \\ \hline
                	   Identity    &                     $p \vee 0 = p$                     &                $p \wedge 1 = p$                 \\ \hline
                	   Zero law    &                                                        &                $p \wedge 0 = 0$                 \\ \hline
                \end{tabular}
                \caption{Basic Boolean laws. These laws satisfy both Boolean and ordinary algebra.}
                \label{Table:Algebralaws}
            \end{table}
        
            \begin{table}[h!]
                \centering
                \begin{tabular}{|c|c|c|}
                	\hline
                	      Law       &               Law of $\vee$               &                   law of $\wedge$                    \\ \hline
                	Distributivity  &                                           & $p \vee (q \wedge r) = (p \vee q) \wedge (p \vee r)$ \\ \hline
                	    One law     &              $p \vee 1 = 1$               &                                                      \\ \hline
                	Idempotence law &              $p \vee p = p$               &                   $p \wedge p = p$                   \\ \hline
                	Absorption law  &         $x \vee (x \wedge y) = x$         &              $x \wedge (x \vee y) = x$               \\ \hline
                	Complement law &            $p \vee \neg p = 1$            &                $p \wedge \neg p = 0$                 \\ \hline
                	De Morgan Laws  & $\neg p \vee  \neg q = \neg (p \wedge q)$ &      $\neg p \wedge  \neg q = \neg (p \vee q)$       \\ \hline
                \end{tabular}
                \caption{Basic Boolean laws. These laws do not have an equivalent in ordinary algebra.}
                \label{Table:Booleanlaws}
            \end{table}
        
        \subsection{Gates}
            
            In this and following sections the physical abstractions to the propositions $true$ and $false$ will be represented by a voltage either being high or low. When the voltage is high we say that the signal is \textit{asserted} and represented by $1$ and when low is \textit{deasserted} and represented by $0$. 
            
            We will use 3 fundamental physical components, \textit{gates}, to implement logic tables or Boolean equations and each of these is represented by a symbol which we will go through in the following.
            
            It should be noted that multiple input are possible with the AND and OR gates since they are both commutative and associative. There will though always be 1 output which is the result of all the subsequent input.
            
            \subsubsection{AND Gate}
                The AND gate is the physical implementation of logic table \ref{LogicTable:AND} we defined earlier. It is illustrated by the symbol found in figure \ref{fig:ANDGate}. 
                
                \begin{figure}[h!]
                    \centering
                    \subimport{tikz_stuff/}{ANDGate}
                    \caption{Illustration of the AND gate where $A$ and $B$ are the input and $A\cdot B$ is the output.}
                    \label{fig:ANDGate}
                \end{figure}
            
            \subsubsection{OR Gate}
                The OR gate is the physical implementation of logic table \ref{LogicTable:OR} we defined earlier. It is illustrated by the symbol found in figure \ref{fig:ORGate}. 
                
                \begin{figure}[h!]
                    \centering
                    \subimport{tikz_stuff/}{ORGate}
                    \caption{Illustration of the OR gate where $A$ and $B$ are the input and $A+B$ is the output.}
                    \label{fig:ORGate}
                \end{figure} 
            
            \subsubsection{NOT Gate}
                The NOT gate or inverter is the physical implementation of logic table \ref{LogicTable:Negation} we defined earlier. It is illustrated by the symbol found in figure \ref{fig:NOTGate}. Usually the inverter is not drawn explicitly, but rather a "bubble" is drawn at the input or output of the respective gate, as shown in figure \ref{fig:NOTGateBubble}. 
                
                \begin{figure}[h!]
                    \centering
                    \subimport{tikz_stuff/}{NOTGate}
                    \caption{Illustration of the NOT gate where $A$ and $B$ are the input and $A+B$ is the output.}
                    \label{fig:NOTGate}
                \end{figure}
            
                \begin{figure}[h!]
                    \centering
                    \begin{subfigure}[b]{0.5\textwidth}
                        \centering
                        \subimport{tikz_stuff/}{ANDGateInput1NOT}
                        \caption{ }
                    \end{subfigure}%
                    \begin{subfigure}[b]{0.5\textwidth}
                        \centering
                        \subimport{tikz_stuff/}{ANDGateInput1NOTBubble}
                        \caption{ }
                    \end{subfigure}%
                    \caption{(a) illustrates the inverter explicitly drawn before the input to the AND gate. (b) shows the inverter illustrated as a bubble before the input to the AND gate.}
                    \label{fig:NOTGateBubble}
                \end{figure}
            
        \improvement{maybe talk about that nor and nand gates are universal}
    \section{Combinational logic}\label{section:Combinational_logic}
        When we design logic units which contain no memory i.e always return the same output given same input, we deal with \textit{combinational logic}. In this section we will go through the essential combinational logic units that will be used throughout this thesis.  \improvement{finish this section} 
        
        \subsection{Decoder}
            The first combinational logic unit we will take a look at will be the \textit{decoder}. Its function is to select one of multiple outputs to assert. This selection is determined by the inputs. 
            
            Say that we have 3 inputs i.e 3 bits of information. There are 8 possible configurations of these 3 bits ($2^{3}=8$) and for each configuration we can assign one output to be asserted. 
            
            In table \ref{LogicTable:Decoder} we have for each configuration asserted one output. Notice that we have used the binary representation of a decimal number to determine which output should be asserted for given input configuration. For example the binary representation for the decimal number $5$ is $101$, so when the input is $In2=1$, $In1=0$ and $In0=1$ output 5 is asserted. 
            
            It should be noted that the choice of which output that should get asserted for given input is arbitrary and up to the logic designer to decide, though each input configuration must only assert one unique output.
            
            We had 3 input in the previous example, but we can generalize the decoder such that for $n$ input, where $n > 0$,  we have $2^{n}$ output. Only one output is asserted per input configuration. 
            
            \begin{table}[h!]
                \centering
                \begin{tabular}{|c|c|c||c|c|c|c|c|c|c|c|}
                    \hline
                    \multicolumn{3}{|c||}{\textbf{Input}}& \multicolumn{8}{c|}{\textbf{Output}}                  \\ \hline
                    In2        & In1        & In0        & Out7 & Out6 & Out5 & Out4 & Out3 & Out2 & Out1 & Out0 \\ \hline
                    0          & 0          & 0          & 0    & 0    & 0    & 0    & 0    & 0    & 0    & 1    \\ \hline
                    0          & 0          & 1          & 0    & 0    & 0    & 0    & 0    & 0    & 1    & 0    \\ \hline
                    0          & 1          & 0          & 0    & 0    & 0    & 0    & 0    & 1    & 0    & 0    \\ \hline
                    0          & 1          & 1          & 0    & 0    & 0    & 0    & 1    & 0    & 0    & 0    \\ \hline
                    1          & 0          & 0          & 0    & 0    & 0    & 1    & 0    & 0    & 0    & 0    \\ \hline
                    1          & 0          & 1          & 0    & 0    & 1    & 0    & 0    & 0    & 0    & 0    \\ \hline
                    1          & 1          & 0          & 0    & 1    & 0    & 0    & 0    & 0    & 0    & 0    \\ \hline
                    1          & 1          & 1          & 1    & 0    & 0    & 0    & 0    & 0    & 0    & 0    \\ \hline
                \end{tabular}
                \caption{Logic Table of a 3 input decoder where the binary representation of the input determines which output gets asserted. For example when In2=1, In1=0, In0=1 output 5 will get asserted as the binary representation for 5 is 101.}
                \label{LogicTable:Decoder}
            \end{table}
        
        \subsection{Multiplexer}
                  
            When we will later deal with larger systems consisting of multiple logic units, we will need a way to select from which unit we want the output to go further up the chain. This select unit is known as a \textit{multiplexer} or \textit{mux}. Its function is to select one of multiple input to output unchanged.
            
            In table \ref{LogicTable:Multiplexer} we have constructed a multiplexer with three input one of which is the control signal $S$. If the control signal is asserted $S=1$ the output will have the value of $B$ and if deasserted $S=0$ it will output the value of $A$. 
            
            In this example we only have two input, but the multiplexer can be made such that it can select between arbitrary many input though this requires an increase in control signals. For $n$ control signals we are able to select between $2^{n}$ input, where $n > 0$.
            \begin{table}[h!]
                \centering
                \begin{tabular}{|c|c|c||c|}
                	\hline
                	\textbf{A} & \textbf{B} & \textbf{S} & \textbf{C} \\ \hline
                	    0      &     0      &     0      &     0      \\ \hline
                	    0      &     1      &     0      &     0      \\ \hline
                	    1      &     0      &     0      &     1      \\ \hline
                	    1      &     1      &     0      &     1      \\ \hline
                	    0      &     0      &     1      &     0      \\ \hline
                	    0      &     1      &     1      &     1      \\ \hline
                	    1      &     0      &     1      &     0      \\ \hline
                	    1      &     1      &     1      &     1      \\ \hline
                \end{tabular}
                \caption{Logic Table of a multiplexer.}
                \label{LogicTable:Multiplexer}
            \end{table}
        
        \subsection{Two-level logic}
        
            We saw in a previous section that it was possible to express any logic table into a logic equation expressed as a sum of one or more products, also known as \textit{disjunctive normal form} or \textit{Sum of Products}.
            As we will see shortly this type of logic expression can be implemented using only two levels of logic, one layer consisting only of AND gates and one only of OR Gates, where negations are only applied to individual variables.
            
            In this and next section we will see an example how one would implement various logic units, such as the multiplexer, going from logic table to the sum of products logic equation and lastly generating a gate-level implementation.
            
              
            
            
        
        \subsection{Programmable logic array}