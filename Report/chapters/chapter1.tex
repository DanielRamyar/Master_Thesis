\chapter{Placeholder}\change{Figure out a title for this chapter}

\section{Communicating Sequential Processes} \change{Rewrite this section} \improvement{add examples of a process and channels}
    The problem with multiprocessor workloads is the sharing of memory. This creates a whole slew of problems. There are many different processes going on at once all having access to the same memory. Unless you got superpowers it is very hard to determine where in the program something goes wrong. It all boils down to the non-determinism. 
    
    For example if you are going to print multiple strings using multiple threads you don't know which string i going to be printed first it's gonna depend on the operating system not on anything in your code. That can create race conditions (meaning the behaviour in your code is dependent on the timing of different threads) which can cause unpredictable behaviour and therefore bugs which is undesirable.
    
    This has been tried to been solved with mutexes or locks but this also have its downside inform of deadlocks where multiple processes are waiting for each other and because these processes are non-deterministic it is very hard to reproduce errors in your code which in turn makes it hard to debug and therefore hard to make reliable software.
    
    This is where Communicating Sequential Processes (CSP) comes in. CSP was an algebra first proposed by \citet{HoareC1978Csp}.
    CSP is build on two very basic primitives one is the process (which should not be confused with operating system processes) which could be an ordered sequence of operations. These processes do not share any memory so one process cannot access a specific value in another process (which solves a lot the problems we had with shared memory).
    
    The other primitive is channels which is the way the processes communicate which each other. You can pass whatever you want through these channels and once you pass a value you loose access to it.
    
    There is a lot of ways the processes and channels can be arranged the most simple one can be found in figure \ref{fig:one_to_one} which illustrates process 1 which passes a value onto a channel which process 2 takes as input. Some different configuations can be found in figures \ref{fig:one_to_many}-\ref{fig:many_to_many}
    
    \begin{figure}[h!]
        \centering
        \subimport{tikz_stuff/}{one_to_one}
        \caption{CSP one to one}
        \label{fig:one_to_one}
    \end{figure}
    
    \begin{figure}[h!]
        \centering
        \subimport{tikz_stuff/}{one_to_many}
        \caption{CSP one to many}
        \label{fig:one_to_many}
    \end{figure}
    
    \begin{figure}[h!]
        \centering
        \subimport{tikz_stuff/}{many_to_one}
        \caption{CSP many to one}
        \label{fig:many_to_one}
    \end{figure}
    
    \begin{figure}[h!]
        \centering
        \subimport{tikz_stuff/}{many_to_many}
        \caption{CSP many to many}
        \label{fig:many_to_many}
    \end{figure}
    
\section{Synchronous Message Exchange}
    \citet{vinter2014synchronous}
    \citet{vinter2015bus}


    
    
    
