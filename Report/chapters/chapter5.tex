\chapter{The RISC-V processor}\label{Chapter:5}
    We are finally at a point where we can start building the RISC-V CPU in SME. At the start of this project I followed the approach described in chapter 4 of the RISC-V book \cite{riscVbook}, but when a functioning CPU was made I quickly came to the realization that the version described in the book was quite inadequate. It only supported a handful instructions, which is not enough to run any but the simplest of programs. 
    
    Therefore I had to sit down and design a version with the requirement of supporting all 49 basic RISC-V instructions \texttt{RV64I}. This design of course took foundation in the book version, with improvements from the lessons learned from the first implementation.
    
    Throughout this chapter we will go through the new design, which can be found here\footnote{\url{https://github.com/DanielRamyar/Master_Thesis/tree/master/SME_Implementations/SingleCycleRISCV2}}.

\section{Single Cycle RISC-V Units}\label{section:riscunits}
    In this section we will explain the function of each of the 12 unique units, used in the implementation of the CPU. This design is single cycle, meaning that only one instruction is executed per clock cycle. 

    \subsection{Program Counter}
        The \textit{program counter}, PC for short, keeps track of where in the program we are located and is a fairly simple unit. It can be thought of as a single register, which holds the address of the current instruction.
        
        To implement the PC unit we create a clocked SME process. It needs to be clocked, meaning the unit will activate on a rising clock edge, as it will part of a closed loop circuit, when we later connect the units. If no unit is clocked in a closed loop, there is no way of knowing, where to begin sending signals. Therefore the PC was chosen to be clocked, as it seemed like the most logical place to start the signal propagation.
        
        The PC process contains a single \texttt{ulong} integer, which will hold the instruction address. The input bus contains the address of the next instruction and the output bus the current. You may ask how the process outputs the current address, when it reads the next address first. Remember that the process is clocked, so when it reads the next address input, it will actually contain the address calculated in the previous clock cycle, as the bus hasn't been updated yet. This would then be the correct address in the current clock cycle.
        
        The PC process has been illustrated in Figure \ref{fig:PC} and a code segment is shown in Listing \ref{PCSME}. 
        
        
        
        \begin{figure}[h!]
            \centering
            \includegraphics[scale=0.2]{pictures/PC.pdf}
            \caption{Illustration of the clocked \texttt{program counter} process having the next address as input and current address as output. The dashed square indicates a clocked process.}
            \label{fig:PC}
        \end{figure}
    
        \begin{minipage}{\linewidth}
            \begin{lstlisting}[language={[Sharp]C}, caption={A slice of the PC unit SME code, which contains a variable that holds the input address. On every cycle edge it then holds and outputs the current address.},captionpos=b, label = PCSME]
...
    ulong address_hold;

    protected override void OnTick() {
        address_hold = m_Input.Address;
        Output.Address = address_hold;
    }
            \end{lstlisting}
        \end{minipage}   
    
    \subsection{Instruction Memory}
        The \textit{instruction memory}, IM for short, contains the program to be run on the CPU. To implement the instruction memory we create a SME process. It contains a byte array with the instructions to be run. A byte array was chosen to respect the conventions discussed in \ref{section:datatranserinstructions}. This also has the added benefit of having a built-in C$\scalerel*{\#}{X}$ function to read a binary file, which automatically puts the instructions contained within the file, in the correct array format. 
        
        The instructions can also be hand written when declaring the array. Since an instruction is 32-bits, 4 elements in the array are needed to form an instruction, where index 0-3 contains the first instruction.
        
        The instruction memory process has a single input from the program counter, which it uses to access the correct instructions. In each cycle we first check whether the address given lies within the instruction array range, if not we shut down the CPU.
        We then construct an instruction to a temporary variable, using methods discussed in \ref{section:Operators}. 
        
        The register fields are then sliced out of this variable and put in the corresponding output buses, \texttt{Read RS1, RS2} and \texttt{Write RS}. The full instruction is also outputted to its own bus, \texttt{Instruction}. Lastly we tell the simulation process to keep the CPU running by asserting the \texttt{CPU} bus. The instruction memory process has been illustrated in Figure \ref{fig:IM} and a code segment is shown Listing \ref{IMSME} explaining parts of the code. 
     
        \begin{figure}[h!]
            \centering
            \includegraphics[scale=0.3]{pictures/IM.pdf}
            \caption{Illustration of the \texttt{instruction memory} process, taking the PC output as input and outputting to the 5 buses, \texttt{Read RS1 and RS2}, \texttt{Write RS}, \texttt{Instruction} and \texttt{CPU}.}
            \label{fig:IM}
        \end{figure}
    
        \begin{minipage}{\linewidth}
            \begin{lstlisting}[language={[Sharp]C}, caption={A slice of the Instruction Memory unit SME code. It contains a single byte array, which holds all the instructions to be run. First we check whether the given address to be accessed lies within instruction array, if not we shut down the CPU. We then use the address to access the correct array elements and create a temporary variable, which contains the instruction, as shown in lines 9-12. Hereafter we slice out the fields in the instruction and place the values in the correct busses. Lastly we tell the simulator to keep the CPU running using the CPU bus.},captionpos=b, label = IMSME]
...
    private readonly byte[] Instruction_Memory = System.IO.File.ReadAllBytes("/Users/danielramyar/Downloads/fibo.bin");
            
    protected override void OnTick() {
        ulong temp_address = m_input.Address;
        uint temp_instruction;
            
        if (temp_address >= 0 && temp_address < (uint)Instruction_Memory.Length) {
            temp_instruction = 0u | (uint)Instruction_Memory[temp_address]     << 24
                                  | (uint)Instruction_Memory[temp_address + 1] << 16
                                  | (uint)Instruction_Memory[temp_address + 2] << 8
                                  | (uint)Instruction_Memory[temp_address + 3];
            
            m_Instruction.Current = temp_instruction;
            m_read_1.Address = (uint)temp_instruction >> 15 & (uint)31; 
            m_read_2.Address = (uint)temp_instruction >> 20 & (uint)31; 
            m_write.Address  = (uint)temp_instruction >> 7  & (uint)31; 
            
            m_CPU.Running = true; // Keep CPU running
        }
        else {
            temp_instruction = 0u; // No Instruction
            ...  // Same as in the if statement
            m_CPU.Running = false; // Turn of cpu no more instructions
    }
            \end{lstlisting}
        \end{minipage}  
        
        
        
    
    \subsection{Next instruction Unit}
        To calculate the address of the next instruction in the queue I have created a unit called \texttt{Next}. This unit is very simple, as its only function is to increment the value found in the PC output bus by 4. We increment by 4, since each instruction is 32 bits long and since our instructions are contained in a byte array, we need to move 4 bytes every time we want to access the following instruction. For example if we are placed at index 0, we would have to go to index 4 to access the next instruction (index 0-3 contains instruction 1 and index 4-7 the next and etc.).
        
        The next instruction process has the output from the program counter as input and sends the incremented address to the \texttt{Next Output} bus. The \texttt{Next} process is illustrated in \ref{fig:NEXT} and a code segment is shown in Listing \ref{NEXTSME}.
        
        \begin{figure}[h!]
            \centering
            \includegraphics[scale=0.34]{pictures/Next.pdf}
            \caption{Illustration of the \texttt{next} process, taking the \texttt{PC output} as input and outputs the next instruction address to the \texttt{next output} bus.}
            \label{fig:NEXT}
        \end{figure}
    
        \begin{minipage}{\linewidth}
            \begin{lstlisting}[language={[Sharp]C}, caption={A slice of the \texttt{Next} process SME code. Here we declare a temporary varible, which contains the program counter output. We increment the temporary variable by four and place it in the output bus.},captionpos=b, label = NEXTSME]
...
    ulong temp;
    
    protected override void OnTick() {
        temp = m_Input.Address + 4;
        Output.Address = temp;
    }
            \end{lstlisting}
        \end{minipage}  
        
    
    \subsection{Register File}
        The \texttt{register}, or RS for short, is a small data storage location for operands of instructions among others (see Table \ref{table:RISCVRegister}). It can be accessed by specifying a register address in an instruction. 
        
        Since R-type instructions use two operands to execute an arithmetic operation, the register has two input lines carrying the address to the specified registers and two output lines carrying the data in the read registers.
        
        Furthermore the result needs to get stored, therefore we need two additional lines one carrying the result of an operation and the other an address for the storage location. To avoid any unintentional write backs to the register, we introduce a write control line, which is asserted if write back is intended.
        
        In SME the register is declared as a process containing a signed 64-bit array with 32 entries. To ensure the latest data is always read, we write to the register as the first thing. Since register 0 is hard-wired to zero according to the conventions, we make sure that the write back address lies within the range 1-31 and that the write control is asserted.
        Lastly we check if the read addresses lie within the range of the register and then output the data in the read registers to the corresponding buses. The \texttt{register} process is illustrated in Figure \ref{fig:REGISTER} and a code segment shown in Listing \ref{REGISTER}.
    
        \begin{figure}[h!]
            \centering
            \includegraphics[scale=0.29]{pictures/REGISTER.pdf}
            \caption{Illustration of the \texttt{register} process. It gets the information on which register addresses to read from \texttt{Read RS1, RS2} buses. To write data the register uses the \texttt{write register} bus to know which register to write to. The \texttt{write data} bus contains the data to be written and the \texttt{write control} bus authorize whether the register should write or not.}
            \label{fig:REGISTER}
        \end{figure}
    
        \begin{minipage}{\linewidth}
            \begin{lstlisting}[language={[Sharp]C}, caption={A slice of the \texttt{register} process SME code. The register is declared as a signed 64-bit array with 32 elements. In every clock cycle the process checks if the write control signal is asserted. If it is, we check if the address to be written lies within the register range and is above 0, as this register is reserved to be hard-wired zero. Lastly the process reads the two specified registers and if they lie within the register range, they get outputted to the corresponding buses.},captionpos=b, label = REGISTER]
...
    private readonly long[] m_register = {0, 0, 0, 0, 0, 0, 0, 0,
                                          0, 0, 0, 0, 0, 0, 0, 0,
                                          0, 0, 0, 0, 0, 0, 0, 0,
                                          0, 0, 0, 0, 0, 0, 0, 0,};
            
    protected override void OnTick() {
        if (m_write_control.Enable == true && m_write.Address > 0 && m_write.Address < 32) {
            m_register[m_write.Address] = m_write_data.Data;          
        }
        if (m_read_1.Address >= 0 && m_read_1.Address < 32) { 
            output_1.Data = m_register[m_read_1.Address];
        }
        if (m_read_2.Address >= 0 && m_read_2.Address < 32) { 
            output_2.Data = m_register[m_read_2.Address];
        }
    }
            \end{lstlisting}
        \end{minipage}  
    
    \subsection{Arithmetic Logic Unit (ALU)}
        The \texttt{Arithmetic Logic Unit}, or ALU for short, is the computational powerhouse of the CPU. It is here all arithmetic, logical, shift and bitwise operations are computed.
        The ALU has two inputs that consist of the operands of an operation. The output is then the result. To determine which operation to perform we additionally have a control line with the operation code or opcode.
        
        In the SME implementation all the operations are enclosed in a \texttt{switch} statement, that is controlled by the opcode to determine which operation to execute. The ALU is illustrated in Figure \ref{fig:ALU} and a code segment is shown in Listing \ref{ALU}.
    
        \begin{figure}[h!]
            \centering
            \includegraphics[scale=0.32]{pictures/ALU.pdf}
            \caption{Illustration of the \texttt{ALU} process. The two input contains the operands of the operation to be executed and the output is the result. The ALU opcode (in red) controls which operations the ALU will perform.}
            \label{fig:ALU}
        \end{figure}
    
        \begin{minipage}{\linewidth}
            \begin{lstlisting}[language={[Sharp]C}, caption={A slice of the \texttt{ALU} process SME code. The ALU consists of a large \texttt{switch} statement, with cases for each operation to be performed, which is controlled by the ALU operation code (\texttt{opcode}). },captionpos=b, label = ALU]
...
    protected override void OnTick() {
        switch (m_ALUOP.Value) {
            case 0:
                output.Value = m_ALU_In_1.Data + m_ALU_In_2.Data;   // ADD
                break;
            case 1:
                output.Value = m_ALU_In_1.Data - m_ALU_In_2.Data;   // SUB
                break;
            case 2:
                output.Value = m_ALU_In_1.Data & m_ALU_In_2.Data;   // AND
                break;
            case 3:
                output.Value = m_ALU_In_1.Data | m_ALU_In_2.Data;   // OR
                break;
            case 4:
                ...
        }
    }
            \end{lstlisting}
        \end{minipage}  
        
    
    \subsection{Immediate generator}\label{section:immediategenerator}
        The \texttt{Immediate Generator}, or IMMGEN for short, extracts immediate fields from instructions. This is a pretty large unit since it needs to know where the immediate field is located in every instruction. To make matters worse some immediate fields in the instructions are totally scrambled, so we have to be really careful on how we reconstruct them.
        
        To start we need to be able to identify which type of instruction we are dealing with to know where the immediate field is located. Luckily almost all types of instructions have a unique operation code (for example the I-type has opcode 19), we therefore use a \texttt{switch} statement in the SME code with the opcode in the instruction as a branching condition to identify the instruction type.
        
        Some instructions of same type, only use the lower 6 bits in the immediate field, such as the \texttt{slli} instruction. To accommodate this fact we make use of another \texttt{switch} statement, within the specific case of the first \texttt{switch} statement, that uses the \texttt{funct3} field as branching condition, since this is the unique identifier within the same type of instruction (for example \texttt{opcode} 19, \texttt{funct3} 1 is the \texttt{slli} instruction).
        
        When we know where the immediate field is located it is time to extract it. This is done by shifting the instruction in question to the right, such that the first bit of the immediate field is located at bit index 0 of the 32-bit instruction. Hereafter we do a bitwise AND operation to remove all but the necessary bits (see Section \ref{section:Operators}). It should be noted that in cases, where the immediate field only is 12-bits long we need to perform a shift to the left and then right to retain the sign bit, as 12-bit numbers are not supported by \texttt{C\#} and therefore does not happen automatically, when cast to \texttt{long} type.
        
        If we deal with \texttt{B-} and \texttt{J-type} instructions, we need to be really careful when we reconstruct the immediate field, as the immediate field bits do not lie in a trivial manner. An important thing to note is that in these types of instructions the first bit is not supplied and therefore should not get shifted all the way to the 0'th bit index but should get shifted to the 1'st bit index. This firstly ensures that we only jump by an even number of bytes, as this is where the base index is for the instructions and secondly it effectively doubles the range we can jump instructions.
        
        When the immediate field is constructed it simply gets outputted as a signed 64-bit number. The immediate generator is illustrated in Figure \ref{fig:IMMGEN} and a code segment is shown in Listing \ref{IMMGEN}.
        
        
        \begin{figure}[h!]
            \centering
            \includegraphics[scale=0.35]{pictures/IMMGEN.pdf}
            \caption{Illustration of the \texttt{immediate generation} process, taking an instruction as input. It then extracts the immediate field, which it outputs. }
            \label{fig:IMMGEN}
        \end{figure}
    
        \begin{minipage}{\linewidth}
            \begin{lstlisting}[language={[Sharp]C}, caption={A slice of the \texttt{IMMGEN} process SME code. We first extract the opcode and funct3 fields from the instruction and put them in a variable. We then use a \texttt{switch} statement and the opcode to determine what type of instruction we are dealing with. Since some instructions of same type like \texttt{slli} only use the lower 6 bits in the immediate field (shamt field), we need another switch statement to tell these apart using the funct3 field. Lastly we construct the immediate and output it . Note that in line 18 we make use of a little hack to retain the sign bit of a 12 bit number since it is not supported in \texttt{C\#}},captionpos=b, label = IMMGEN]
...
    protected override void OnTick() {
        uint Opcode = m_instruction.Current & (uint)0x7F;
        uint funct3 = m_instruction.Current >> 12 & (uint)0x7;
            
        switch(Opcode) {
            ...
            case 19:                                        // I-format
                switch (funct3) {
                    ...
                    case 5:
                        temp1 = m_instruction.Current >> 20 & (uint)0x3F;
                        temp0 = (long)temp1;
                        output.Immediate = temp0;
                        break;
                    default:
                        temp1 = m_instruction.Current >> 20 & (uint)0xFFF;
                        short temp5 = (short)((short)(temp1 << 4) >> 4);
                        temp0 = (long)temp5;
                        output.Immediate = temp0;
                        break;
                }
            break;
            case 27:                                        // I-format Word
                ....
        }
    }
            \end{lstlisting}
        \end{minipage} 
\newpage
    \subsection{Data Memory}
        The \texttt{Data Memory}, or DM for short, is the main data storage unit of the CPU, as it can contain much more data than the register. The data memory is very similar to the instruction memory, as it is also little-endian addressed and is constructed from a byte array. The processor can either read or write from the data memory unit once per clock cycle.
        
        Because of this fact the data memory needs control signals, which manages read and write access. To support data of varying size an additional control signal has been added to distinguish between double word, word, short and byte access. Since unsigned versions of the \texttt{load} instructions also needs to be supported, this functionality is added to the size control signal.
        
        As the data memory communicates with the register, which is big-endian addressed and every element is 64-bit, a translation needs to happen between these formats.
        
        In SME a process is created that contains a byte array. To support 64-bit numbers the array has to be larger than 8 bytes if a single number has to be stored. Otherwise the sizing is irrelevant if made big enough and is divisible by eight. In this implementation the array is chosen 2000 bytes long to make sure it is big enough.
        
        To distinguish between the read and write states an \texttt{if/else} statement is used. For the branching condition, two control signals are used to determine whether a read or write should be performed. When reading or writing the size of the data needs to be known, such that a correct translation between big- and little-endian formats can take place. To this end a \texttt{switch} statement is used, with cases for each data size scenario. Furthermore cases for handling unsigned reads has been added.
        
        The read and write address gets calculated by the ALU and the data is supplied by the second register output line. If the read control is enabled the data memory will output the specified data. The data memory is illustrated in Figure \ref{fig:DM} and a code segment is shown in Listing \ref{DM}.
        
        \begin{figure}[h!]
            \centering
            \includegraphics[scale=0.29]{pictures/DM.pdf}
            \caption{Illustration of the \texttt{Data Memory} process. The target address is calculated in the ALU and data to be written outputted from register 2, which the unit takes as input. Controls signals are marked in red and consists of \texttt{Memory Read}, \texttt{Memory Write} and \texttt{Size and Sign}. It then outputs the read data or 0 if both \texttt{Memory Read} and \texttt{Memory Write} are deasserted.}
            \label{fig:DM}
        \end{figure}
    
        \begin{minipage}{\linewidth}
            \begin{lstlisting}[language={[Sharp]C}, caption={A slice of the \texttt{Data Memory} process SME code. Similar to the instruction memory, the data memory consists of a byte array, which we made 2000 elements long in this case. As there can only be read or written to the data memory once per clock cycle, we simply construct an \texttt{if/else} statement, which uses control signals to determine the procedure to be done. Both the read and write procedures need to know the size and sign of the data to be loaded or written. Therefore a \texttt{switch} statement has been added to both outcomes, which uses \texttt{SizeAndSign} control signal to choose between the cases. When reading the data from memory we need to remember that it is little-endian addressed  so before we output the value the bits need to be shuffled around in the correct order, so the correct value is added to the register, as that is big-endian. When writing the data the opposite need to happen, so a big-endian value need to be converted to a little-endian one. If both read and write control signals are deasserted I choose to output 0.},captionpos=b, label = DM]
...
    byte[] Data_Memory = new byte[2000];
            
    protected override void OnTick() {
        if (m_MemRead.Enable) {
            ...
            switch (m_SizeAndSign.Value) {
                ...
                case 1: // load word
                    temp0 =
                    Data_Memory[m_Address.Value] | Data_Memory[m_Address.Value + 1] << 8
                                                 | Data_Memory[m_Address.Value + 2] << 16
                                          | (sbyte)Data_Memory[m_Address.Value + 3] << 24;
                    break;
                case 2: // load short
                    ...
            }
            output.Data = temp0;
        }
        else if (m_MemWrite.Enable) {
            switch (m_SizeAndSign.Value) {
                ...
                case 2:
                    Data_Memory[m_Address.Value]     = (byte)(m_Data_input.Data      & 0xFF);
                    Data_Memory[m_Address.Value + 1] = (byte)(m_Data_input.Data >> 8 & 0xFF);
                    break;
                case 3:
                    Data_Memory[m_Address.Value] = (byte)(m_Data_input.Data & 0xFF); 
                    break;
            }
        }
        else {
            output.Data = 0;
        }
    }
            \end{lstlisting}
        \end{minipage} 
    
    \subsection{GoTo Unit}
        To support the RISC-V branching and jump instructions a special unit called \texttt{GoTo} was created. The purpose of this unit is to do the logical comparison between the specified registers. For example if the \texttt{branch if equal} (\texttt{BEQ}) instruction is given, the unit will check if the values in the specified registers are equal and outputs logical \texttt{true} or \texttt{false} depending on the result.
        
        In the SME implementation a simple \texttt{switch} statement is used. Each case represent the comparison to be done by a given instruction, where the case branching is controlled by a control line. The result is then outputted. The \texttt{GoTo} unit is illustrated in Figure \ref{fig:GOTO} and a code segment is shown in Listing \ref{GOTO}.
        
        
        \begin{figure}[h!]
            \centering
            \includegraphics[scale=0.35]{pictures/GOTO.pdf}
            \caption{Illustration of the \texttt{GoTo} process. As input it uses the two output lines from the register. It has one control line in red and one output line in green.}
            \label{fig:GOTO}
        \end{figure}
    
        \begin{minipage}{\linewidth}
            \begin{lstlisting}[language={[Sharp]C}, caption={A slice of the \texttt{GoTo} process SME code. The unit consists of a \texttt{switch} statement, where each case does the comparison relevant to the branching instruction. The conditional operator \texttt{?} is used for the comparison (the syntax goes as follows \texttt{condition ? If true return this : If false return this}).},captionpos=b, label = GOTO]
...
    protected override void OnTick() {
        switch (m_BJSIGN.Value) {
            case 0:
                output.Value = (m_RS1.Data == m_RS2.Data) ? true:false; // BEQ
                break;
            case 1:
                output.Value = (m_RS1.Data != m_RS2.Data) ? true:false; // BNE
                break;
            case 2:
                ...
        }
    }
            \end{lstlisting}
        \end{minipage}
    
    \subsection{Multiplexer}
        To select between multiple lines we make use of a \texttt{multiplexer}, or mux. It is a fairly simple process that only consists of a \texttt{switch} statement, where each case corresponds to an input to output. The cases then gets selected depending on the control line. The multiplexer is illustrated in Figure \ref{fig:MUX} and a code segment is shown in Listing \ref{MUX}.
        
        \begin{figure}[h!]
            \centering
            \includegraphics[scale=0.35]{pictures/MUX.pdf}
            \caption{Illustration of the \texttt{Multiplexer} process. An arbitrary amount of input can be given, where the output is selected by the red control line. }
            \label{fig:MUX}
        \end{figure}
    
        \begin{minipage}{\linewidth}
            \begin{lstlisting}[language={[Sharp]C}, caption={An example of a \texttt{Multiplexer} process SME code. The whole multiplexer simply consists of a \texttt{switch} statement that selects an input to output dependent on \texttt{SelectBus}.},captionpos=b, label = MUX]
...
    protected override void OnTick() {
        switch (SelectBus) {
            case 0:
                Mux_output = input1;
                break;
            case 1:
                Mux_output = input2; 
                break;
            case 2:
                Mux_output = input3; 
                break;
        }
    }
            \end{lstlisting}
        \end{minipage}
\newpage
    \subsection{Write Back Unit}
        When wiring the processor there is going to form a second closed loop between the register and data memory. As with the closed loop between the program counter and Next unit, there has to be a clocked process somewhere in the loop. For this reason a clocked write back process is introduced. It works exactly the same as the program counter, which read the contents of a bus that contained data from the previous clock cycle and got outputted unchanged. 
        
        It may seem that this could cause problems, but as the data output from this unit gets written to the register as the first thing, instructions will never access old data.  The \texttt{Write Back} unit is illustrated in Figure \ref{fig:WB} and a code segment is shown in Listing \ref{WB}.
        \begin{figure}[h!]
            \centering
            \includegraphics[scale=0.35]{pictures/WB.pdf}
            \caption{Illustration of the \texttt{Write Back} process. It has 3 input \texttt{Data}, \texttt{Write Register} and \texttt{Write control}. These input gets outputted unchanged to their respective output buses. The dashed square indicates a clocked process.}
            \label{fig:WB}
        \end{figure}
    
        \begin{minipage}{\linewidth}
            \begin{lstlisting}[language={[Sharp]C}, caption={A slice of the \texttt{Write Back} process SME code. It contains 3 variables, which will hold the incomming values, which gets outputted unchanged in the same clock cycle.},captionpos=b, label = WB]
...
    long WB_Data_Hold;
    uint WB_RegisterWrite_Hold;
    bool WB_WriteControl_Hold;
    
    protected override void OnTick() {
        WB_Data_Hold = m_write_data.Data;
        WB_RegisterWrite_Hold = m_write_register.Address;
        WB_WriteControl_Hold = m_write_control.Enable;
    
        m_WB_Data.Data = WB_Data_Hold;
        m_WB_WriteRegister.Address = WB_RegisterWrite_Hold;
        m_WB_WriteControl.Enable = WB_WriteControl_Hold;
    }
            \end{lstlisting}
        \end{minipage} 
    
    \subsection{AND gate unit}
        To make use of a trick inspired from the RISC-V implementation in chapter 4 of \cite{riscVbook} an AND gate unit has been implemented. The purpose of this unit is to check whether branching or jumping instructions are given. If such instructions are taking place a control signal is asserted. The AND gate only returns true if the branching condition from the \texttt{GoTo} unit returns true. This result can now be feed to a multiplexer which chooses whether to run next instruction or jump in the instruction memory. The \texttt{AND} unit is illustrated in Figure \ref{fig:AND} and a code segment is shown in Listing \ref{AND}.
        
        \begin{figure}[h!]
            \centering
            \includegraphics[scale=0.35]{pictures/AND.pdf}
            \caption{Illustration of the \texttt{AND gate} process. It has two input one from the \texttt{GoTo} unit and one from the \texttt{control unit} named \texttt{PCSel}. The output is then the result of the logical AND operation between the two input.}
            \label{fig:AND}
        \end{figure}
    
        \begin{minipage}{\linewidth}
            \begin{lstlisting}[language={[Sharp]C}, caption={A slice of the \texttt{AND gate} process SME code. It simply calculates the logical AND of two input and outputs the result.},captionpos=b, label = AND]
...
    protected override void OnTick() {
        Output.Value = m_Input_1.Value && m_Input_2.Value;
    }
            \end{lstlisting}
        \end{minipage} 
        
    \subsection{Control}
        The final unit that is to be shown is the \texttt{Control} unit. This is quite a substantial unit, as its function is to correctly set the values for the control lines for all 49 instructions. What the values look like will be discussed in Section \ref{section:Datapaths}. For now the SME implementation will be covered.
        
        This unit uses a similar solution for instruction detection, as the \texttt{Immediate Generator} (see Section \ref{section:immediategenerator}). To identify the current instruction the \texttt{opcode}, \texttt{funct3} and \texttt{funct7} fields are extracted from the 32-bit instruction input and put in their respective variables. All 3 fields are used this time, as every instruction needs to be identified to correctly set the control lines.
        
        Multiple \texttt{switch} statements are layered for instruction detection. The first \texttt{switch} uses the \texttt{opcode} to determine the type of instruction that is currently running. Say an R-type instruction has been identified. Most control lines can be set here, as only the control line for the ALU is different between the R-type instructions. To set the last control line a second \texttt{switch} statement is used with the \texttt{funct3} field as branching condition to identify which R-type instruction is given. Since some R-type instructions have the same \texttt{funct3} code, a third \texttt{switch} statement is required to differentiate these.
        
        When an instruction has been identified the control lines are set to the correct values and outputted. The \texttt{Control} unit is illustrated in Figure \ref{fig:CONTROL} and a code segment is shown in Listing \ref{CONTROL}.
        
        
        \begin{figure}[h!]
            \centering
            \includegraphics[scale=0.35]{pictures/CONTROL.pdf}
            \caption{Illustration of the \texttt{Control} process. It takes a 32-bit instruction as input and sets the control lines for the respective instruction.}
            \label{fig:CONTROL}
        \end{figure}
    
        \begin{minipage}{\linewidth}
            \begin{lstlisting}[language={[Sharp]C}, caption={A slice of the \texttt{Control} process SME code. First 3 variables are declared for the extracted \texttt{opcode}, \texttt{funct3} and \texttt{func7} fields. They are then used in the following \texttt{switch} statements to correctly identify the given instruction. Finally the control lines are set with the values for the respective instruction.},captionpos=b, label = CONTROL]
...
    protected override void OnTick() {
        uint Opcode = m_instruction.Current       & (uint)0x7F;  
        uint funct3 = m_instruction.Current >> 12 & (uint)0x7;  
        uint funct7 = m_instruction.Current >> 25 & (uint)0x7F;
        switch (Opcode) {
            ...
            case 51:                            // R-format
                PCSel.Value = false;
                RegWrite.Enable = true;
                ALUSrc1.Enable = false;
                ALUSrc2.Enable = false;
                BJSIGN.Value = 0;
                SizeAndSign.Value = 0;
                MemWrite.Enable = false;
                MemRead.Enable = false;
                WBSel.Value = 0;
                
                switch (funct3) {
                    case 5:
                        switch (funct7) {
                            case 0:                         // ADD
                            ALUOP.Value = 0;
                            break;
                        case 32:                        // Subtract
                            ALUOP.Value = 1;
                            break;
                        }
                        break;
                    ...
            ...
        }
    }
            \end{lstlisting}
        \end{minipage} 
\newpage
\section{Single Cycle RISC-V datapaths}\label{section:Datapaths}
    In Section \ref{section:riscunits} all necessary units for the RISC-V implementation were covered. The final step is to connect all units and define the instruction datapaths. The datapath is defined as the path an instruction takes through the RISC-V implementation. The full implementation is illustrated in Figure \ref{fig:RISCV}. 
    
    The unit that determines what path an instruction takes is the control unit. By modifying the values in the control signals, the path an instruction takes can be manipulated. Since the different types of instructions need to follow a very specific path, we need to design the control unit such that the correct paths get taken.
    
    \begin{figure}[h!]
        \hspace*{-3.8cm}
        \centering
        \includegraphics[scale=0.8]{pictures/RISCV.pdf}
        \caption{An illustration of the wired RISC-V CPU.}
        \label{fig:RISCV}
    \end{figure} 

    \subsection{Supporting R-Format instructions}\label{section:Rformat}
        All R-format instructions perform some arithmetic or logical operations on 2 operands in the register and saves the result back into some specified register. For that to take place two registers has to be read and sent to the \texttt{ALU} where the operation takes place. Therefore the control signals \texttt{ALUSrc1} and \texttt{ALUSrc2} controlling \texttt{mux2} and \texttt{mux3} need to be deasserted, such that they output the values read in the two registers. 
        
        The control signal \texttt{ALUop} that controls the \texttt{ALU} is then set to the operation to be performed by the R-type instruction and range between 0 and 14. The value that gets written back to the register is then determined by \texttt{mux4}. Since it is the result of the \texttt{ALU} that has to be written back into some specified register, input 0 of \texttt{mux4} is selected by setting \texttt{WBSel} to zero and the write control line \texttt{RegWrite} of the register is asserted.
        
        The data memory is never accessed so all its control lines are deasserted.
        
        Finally the \texttt{PCSel} line is deasserted (so the value \texttt{BJSIGN} automatically becomes irrelevant) such that address of the next instruction is inputted to the program counter, since R-format instructions do not perform any branching. Every control signal value is summarized in Table \ref{table:RFORMAT}. For full table please refer to Appendix \ref{appendix:Controlsignalvalues}.
        
        \begin{table}[h!]
            \small
            \hspace{-2.4cm}
            \begin{tabular}{|c||c|c|c|c|c|c|c|c|c|c|}
            	\hline
            	                  & \textbf{PCSel} & \textbf{RegWrite} & \textbf{ALUSrc1} & \textbf{ALUSrc2} & \textbf{ALUop} & \textbf{BJSIGN} & \textbf{SizeAndSign} & \textbf{MemWrite} & \textbf{MemRead} & \textbf{WBSel} \\ \hline\hline
            	\textbf{R-Format} &       0        &         1         &        0         &        0         &      0-14      &        0        &          0           &         0         &        0         &       0        \\ \hline
            \end{tabular}
            \caption{This table shows control line values for the R-format datapath. Only the \texttt{ALUop} line is different between the R-format instructions and the values range from 0 to 14.}
            \label{table:RFORMAT}
        \end{table}
    
    \subsection{Supporting I-Format instructions}
        The I-Format instructions perform an arithmetic or logical operation between one operand in the register and one operand contained within the immediate field of the instruction. The result is then saved to some specified register. Therefore the only difference between the I- and R-Format instructions are the second operand, which instead comes from the immediate field. 
        
        For this reason the only change that needs to be made to the control lines compared to the R-Format instructions are that the \texttt{ALUSrc2} line gets asserted, such that the second input to the \texttt{ALU} comes from the immediate field. All other control lines follow the same reasoning as the R-Format, which can be read in Section \ref{section:Rformat}. Every control signal value is summarized in Table \ref{table:IFORMAT}. For full table please refer to Appendix \ref{appendix:Controlsignalvalues}.
        
        \begin{table}[h!]
            \small
            \hspace{-2.4cm}
            \begin{tabular}{|c||c|c|c|c|c|c|c|c|c|c|}
            	\hline
            	                  & \textbf{PCSel} & \textbf{RegWrite} & \textbf{ALUSrc1} & \textbf{ALUSrc2} & \textbf{ALUop} & \textbf{BJSIGN} & \textbf{SizeAndSign} & \textbf{MemWrite} & \textbf{MemRead} & \textbf{WBSel} \\ \hline\hline
            	\textbf{I-Format} &       0        &         1         &        0         &        1         &      0-14      &        0        &          0           &         0         &        0         &       0        \\ \hline
            \end{tabular}
            \caption{This table shows control line values for the I-format datapath. Only the \texttt{ALUop} line is different between the I-format instructions and the values range from 0 to 14.}
            \label{table:IFORMAT}
        \end{table}
    
        \subsubsection{Load instructions}
            The load instructions is a special case of the I-Format instructions. Compared to the general I-Format instruction, only the sum between the register and immediate is calculated, so \texttt{ALUOp} is always set to 0.
            
            To load from the data memory the size of data needs to be known. Furthermore unsigned loads are available in the basic RISC-V instruction set. This information is stored within the \texttt{SizeAndSign} control line and ranges between the values 0 and 6.
            
            Since we read the memory the \texttt{MemRead} control line is asserted and the control line for \texttt{mux4} is set to 1, as it is the value read from the data memory that has to get written back to the register.
            
            Every control signal value is summarized in Table \ref{table:LOADFORMAT}. For full table please refer to Appendix \ref{appendix:Controlsignalvalues}.
            
            
            \begin{table}[h!]
                \small
                \hspace{-2.4cm}
                \begin{tabular}{|c||c|c|c|c|c|c|c|c|c|c|}
                	\hline
                	                  & \textbf{PCSel} & \textbf{RegWrite} & \textbf{ALUSrc1} & \textbf{ALUSrc2} & \textbf{ALUop} & \textbf{BJSIGN} & \textbf{SizeAndSign} & \textbf{MemWrite} & \textbf{MemRead} & \textbf{WBSel} \\ \hline\hline
                	\textbf{I-Format} &       0        &         1         &        0         &        1         &      0      &        0        &          0-6           &         0         &        1         &       1        \\ \hline
                \end{tabular}
                \caption{This table shows control line values for the special case I-format \texttt{load} instruction datapath. }
                \label{table:LOADFORMAT}
            \end{table}
        
        \subsubsection{Jump and link register}
            The \texttt{jump and link register} is another special case of the I-Format instruction where (as with the \texttt{load} instruction) only the sum between the register and immediate is calculated, so \texttt{ALUOp} is always set to 0.
            
            This sum is then sent directly back to the program counter from the ALU, which is then selected by \texttt{mux1}. For this selection to happen the AND gate needs to return 1, which can only happen if \texttt{PCSel} is asserted. Furthermore a special case has been added to the \texttt{GoTo} unit, which automatically asserts its output. This happens if \texttt{BJSIGN} is set to 6. This combination allows \texttt{mux1} to select the ALU output.
            
            To save the output from the \texttt{NEXT} unit (which is the address of the following instruction) back to some specified register, the control line \texttt{WBsel} for \texttt{mux4} is set to 2. The data memory is not accessed hence all control lines going to the data memory is deasserted.
            
            Every control signal value is summarized in Table \ref{table:JALRFORMAT}. For full table please refer to Appendix \ref{appendix:Controlsignalvalues}.
            
            \begin{table}[h!]
                \small
                \hspace{-2.4cm}
                \begin{tabular}{|c||c|c|c|c|c|c|c|c|c|c|}
                	\hline
                	                  & \textbf{PCSel} & \textbf{RegWrite} & \textbf{ALUSrc1} & \textbf{ALUSrc2} & \textbf{ALUop} & \textbf{BJSIGN} & \textbf{SizeAndSign} & \textbf{MemWrite} & \textbf{MemRead} & \textbf{WBSel} \\ \hline\hline
                	\textbf{I-Format} &       1        &         1         &        0         &        1         &       0        &        6        &         0          &         0         &        0         &       2        \\ \hline
                \end{tabular}
                \caption{This table shows control line values for the special case I-format \texttt{jalr} instruction datapath. }
                \label{table:JALRFORMAT}
            \end{table}
        
    
    \subsection{Supporting S-Format instructions}
        The S-Format instructions move data stored in registers to the data memory. No write back to the register happens, therefore the register write control is deasserted. Because of this it does not matter what value \texttt{WBSel} control line has. 
        
        To calculate the address to which the data is to be saved, the base address stored in a register is used. This register is read and sent out to the \texttt{RS1} read line. For this reason the control line \texttt{ALUSrc1} for \texttt{mux2} is deasserted. The offset to the base address lies within the immediate field, so the control line \texttt{ALUSrc2} for \texttt{mux3} is asserted.
        
        The ALU then finds the sum between the address given by the \texttt{RS1} line and the offset given by the immediate line. Addition is defined as case 0 in the \texttt{ALU} therefore opcode 0 is set for the ALU control line.
        
        The data memory needs to know whether the data to be stored is a byte, half, word or double word, so the control line \texttt{SizeAndSign} range between 0 and 3 and is set depending on the given S-type instruction. The data to be stored comes from the second register line and is directly connected to the data memory. Since the data memory will get written to the control line \texttt{MemWrite} is asserted to authorize this. No read is happening so \texttt{MemRead} is deasserted.
        
        Finally the \texttt{PCSel} line is deasserted (so the value \texttt{BJSIGN} automatically becomes irrelevant) such that address of the next instruction is inputted to the program counter, since S-format instructions do not perform any branching. Every control signal value is summarized in Table \ref{table:SFORMAT}. For full table please refer to Appendix \ref{appendix:Controlsignalvalues}.
        
        
        \begin{table}[h!]
            \small
            \hspace{-2.4cm}
            \begin{tabular}{|c||c|c|c|c|c|c|c|c|c|c|}
            	\hline
            	                  & \textbf{PCSel} & \textbf{RegWrite} & \textbf{ALUSrc1} & \textbf{ALUSrc2} & \textbf{ALUop} & \textbf{BJSIGN} & \textbf{SizeAndSign} & \textbf{MemWrite} & \textbf{MemRead} & \textbf{WBSel} \\ \hline\hline
            	\textbf{S-Format} &       0        &         0         &        0         &        1         &       0        &        0        &         0-3          &         1         &        0         &       0        \\ \hline
            \end{tabular}
            \caption{This table shows control line values for the S-format datapath.}
            \label{table:SFORMAT}
        \end{table}
    
    \subsection{Supporting B-Format instructions}
        The B-Format instructions, also known as branching instructions, determine whether the following instruction or an alternate instruction, located at a different address should be run next. This is  based on some branching condition.
        
        The address of the alternate instruction is calculated using the current address and an offset specified in the immediate field of the branching instruction. Therefore both control signals, \texttt{ALUSrc1} and \texttt{ALUSrc2}, going to \texttt{mux2} and \texttt{mux3} is asserted. The ALU then needs to find the sum between them so \texttt{ALUop} is set to 0. Hereafter the result gets sent back to \texttt{mux1}.
        
        \texttt{PCSel} is asserted since the AND gate needs to be able to output 1. To determine whether the branching should happen the \texttt{GoTo} unit compare the values given to lines \texttt{RS1} and \texttt{RS2}. There are 6 different comparisons, so the \texttt{BJSIGN} control line is used to choose the right one depending on the given instruction. The values range between 0 and 5.
        
        Since the memory is not accessed and the register is not written to, all the respective control lines are deasserted. Every control signal value is summarized in Table \ref{table:BFORMAT}. For full table please refer to Appendix \ref{appendix:Controlsignalvalues}.
        
        \begin{table}[h!]
            \small
            \hspace{-2.4cm}
            \begin{tabular}{|c||c|c|c|c|c|c|c|c|c|c|}
            	\hline
            	                  & \textbf{PCSel} & \textbf{RegWrite} & \textbf{ALUSrc1} & \textbf{ALUSrc2} & \textbf{ALUop} & \textbf{BJSIGN} & \textbf{SizeAndSign} & \textbf{MemWrite} & \textbf{MemRead} & \textbf{WBSel} \\ \hline\hline
            	\textbf{B-Format} &       1        &         0         &        1         &        1         &       0        &        0-5        &         0          &         0         &        0         &       0        \\ \hline
            \end{tabular}
            \caption{This table shows control line values for the B-format datapath.}
            \label{table:BFORMAT}
        \end{table}
    \subsection{Supporting U-Format instructions}
        There are two U-Format instructions, \texttt{AUIPC} and \texttt{LUI}. They are both very similar as they load some value to a register destination. 
        
        \texttt{LUI} loads a shifted immediate to the register. The immediate shift is done in the \texttt{ImmGen} unit, so a special case has been added to the ALU, which outputs the value given to the second ALU input. This case is chosen when \texttt{ALUop} is set to 15. 
        To get the immediate field to the ALU, \texttt{ALUSrc2} going to \texttt{mux3} is asserted.
        The first ALU input is irrelevant in this case so the value of \texttt{ALUSrc1} does not matter. 
        
         \texttt{AUIPC} on the other hand adds the shifted immediate to the current address in the program counter, so the control line \texttt{ALUSrc1} going to \texttt{mux2} gets asserted and again to get the immediate field to ALU, \texttt{ALUSrc2} is asserted. \texttt{ALUop} is set to 0 to find the sum between the current address and immediate input for the \texttt{AUIPC} instruction.
         
         Since a register write is taking place \texttt{RegWrite} is asserted and \texttt{WBSel} is set to 0 to select the ALU output. The data memory is never accessed so all control lines going to it are deasserted. Finally the \texttt{PCSel} line is deasserted (so the value \texttt{BJSIGN} automatically becomes irrelevant) such that address of the next instruction is inputted to the program counter, since U-format instructions do not perform any branching. Every control signal value is summarized in Table \ref{table:UFORMAT}. For full table please refer to Appendix \ref{appendix:Controlsignalvalues}.
    
        \begin{table}[h!]
            \small
            \hspace{-2.4cm}
            \begin{tabular}{|c||c|c|c|c|c|c|c|c|c|c|}
            	\hline
            	                  & \textbf{PCSel} & \textbf{RegWrite} & \textbf{ALUSrc1} & \textbf{ALUSrc2} & \textbf{ALUop} & \textbf{BJSIGN} & \textbf{SizeAndSign} & \textbf{MemWrite} & \textbf{MemRead} & \textbf{WBSel} \\ \hline\hline
            	\textbf{U-Format} &       0        &         1         &      1 or 0      &        1         &    0 or 15     &        0        &          0           &         0         &        0         &       0        \\ \hline
            \end{tabular}
            \caption{This table shows control line values for the U-format datapath. \texttt{ALUSrc1} is asserted for \texttt{AUIPC} and deasserted for \texttt{LUI}. \texttt{ALUop} is set to 0 for \texttt{AUIPC} and set to 15 for \texttt{LUI}.}
            \label{table:UFORMAT}
        \end{table}
    
    \subsection{Supporting J-Format instructions}
        There is only a single J-Format instruction in the \texttt{RV64I} basic instruction set, which is called jump and link, \texttt{JAL}. It is very similar to the \texttt{JALR} instruction. But instead of branching relative to a value stored in the register, \texttt{JAL} branches relative to the current instruction address stored in the program counter. For this reason the control line \texttt{ALUSrc1} going to \texttt{mux2} gets asserted. The offset used to calculate the alternate address is stored in the immediate field of the instruction, so \texttt{ALUSrc2} going to \texttt{mux3} gets asserted. The ALU then has to find the sum between the two values, so \texttt{ALUop} is set to 0.
        
        As with the case with \texttt{JALR}, the ALU output needs to be sent back to the program counter so \texttt{PCSel} is asserted and \texttt{BJSIGN} is set to 6, which automatically makes the \texttt{GoTo} unit return 1.
        
        To save the output from the \texttt{NEXT} instruction unit, which is the address of the following instruction, back to some specified register, the control line \texttt{WBsel} for \texttt{mux4} is set to 2 and \texttt{RegWrite} is asserted. The data memory is not accessed hence all control lines going to the data memory is deasserted.
        
        Every control signal value is summarized in Table \ref{table:JFORMAT}. For full table please refer to Appendix \ref{appendix:Controlsignalvalues}.
         
        
        \begin{table}[h!]
            \small
            \hspace{-2.4cm}
            \begin{tabular}{|c||c|c|c|c|c|c|c|c|c|c|}
            	\hline
            	                  & \textbf{PCSel} & \textbf{RegWrite} & \textbf{ALUSrc1} & \textbf{ALUSrc2} & \textbf{ALUop} & \textbf{BJSIGN} & \textbf{SizeAndSign} & \textbf{MemWrite} & \textbf{MemRead} & \textbf{WBSel} \\ \hline\hline
            	\textbf{U-Format} &       1        &         1         &        1         &        1         &       0        &        6        &          0           &         0         &        0         &       2        \\ \hline
            \end{tabular}
            \caption{This table shows control line values for the J-format datapath.}
            \label{table:JFORMAT}
        \end{table}
    
    \subsection{Special Zero instruction}
        The zero instruction simply deasserts all control lines. This instruction was added to mark an end to a program. So when this instruction is run the CPU shuts down. Every control signal value is summarized in Table \ref{table:ZEROFORMAT}. 
        
        \begin{table}[h!]
            \small
            \hspace{-2.4cm}
            \begin{tabular}{|c||c|c|c|c|c|c|c|c|c|c|}
                \hline
                & \textbf{PCSel} & \textbf{RegWrite} & \textbf{ALUSrc1} & \textbf{ALUSrc2} & \textbf{ALUop} & \textbf{BJSIGN} & \textbf{SizeAndSign} & \textbf{MemWrite} & \textbf{MemRead} & \textbf{WBSel} \\ \hline\hline
                \textbf{U-Format} &       0        &         0         &        0         &        0         &       0        &        0        &          0           &         0         &        0         &       0        \\ \hline
            \end{tabular}
            \caption{This table shows control line values for the Zero instruction datapath.}
            \label{table:ZEROFORMAT}
        \end{table} 
    
    
\section{Debugging the instructions}
    We are now at a point where instructions can be run on the CPU. Extensive testing has been done to confirm that the behavior of the instructions are correct. To test the individual instructions a small program is written in \texttt{Jupiter}\footnote{\url{https://github.com/andrescv/Jupiter}}. Only a single instruction test are going to be covered here, but all assembly and binary instruction testers can be found here\footnote{\url{https://github.com/DanielRamyar/Master_Thesis/tree/master/SME_Implementations/SingleCycleRISCV2/RISCVTESTERS}}.
    
    To test the \texttt{add} instruction the following program has been written
    

        \begin{lstlisting}[language={[Sharp]C}]
.global __start

__start:
    addi x0, x0, 10 # Check to see if register 0 can be written to
    
    addi x13, x0, -2048 # x13 = -2048
    addi x14, x0, -5    # Set regiser 14 to have value -5
    addi x15, x0, 1     # Set regiser 15 to have value 1
    addi x16, x0, 8     # Set regiser 16 to have value 8
    addi x17, x0, 7     # Set regiser 17 to have value 7
    
    add x18, x17, x16 # x18 = x17 + x16 | 15 = 7 + 8
    add x19, x16, x17 # x19 = x16 + x17 | 15 = 8 + 7
    add x20, x13, x16 # x20 = x13 + x16 | -2040 = -2048 + 8
    add x21, x16, x13 # x21 = x16 + x13 | -2040 = 8 - 2048
        \end{lstlisting}

    
    First data values are loaded into the register. The values are chosen such that both negative and position operands in the addition can be verified. On line 12 positive operands are tested. The values are then swapped in the following line to make sure this does not affect the result.
    
    On lines 14 and 15 the same procedure is then repeated to check if mixed positive and negative numbers exhibit correct behavior.
    
    To run the shown assembly code on the CPU a hex dump is done in Jupiter, which looks like the following
    

        \begin{lstlisting}[language={[Sharp]C}]
0x00a00013
0x80000693
0xffb00713
0x00100793
0x00800813
0x00700893
0x01088933
0x011809b3
0x01068a33
0x00d80ab3
0x00000000 <- This zero instruction is added manually  
        \end{lstlisting}

    To mark the end of the program a zero instruction is manually added at the end of the hex numbers. The hex dumps can also be found in the \texttt{RISCVTESTERS} folder. As the CPU instruction memory imports program using the binary read command the hex file is converted to binary.
    
    A hex to binary converter was used for this purpose and can be found here\footnote{\url{https://tomeko.net/online_tools/hex_to_file.php?lang=en}}. The hex dump simply gets pasted into hex string field of the site. To have the correct format for the binary import command \texttt{myfile.dat} is changed to \texttt{myfile.bin}. Convert is then pressed and the file automatically gets downloaded to the system. All binary files are also located in the \texttt{RISVTESTERS} folder.
    
    The path to the file is then given to the instruction memory. Then the \texttt{dotnet run} command is run in the terminal and the program is executed. The register is then checked to see if the correct registers contain the correct values.
    
    \subsection{Writing simple C code to run on RISC-V}
        When all instructions have been tested a \texttt{C} program is written to see if a larger compiled program behaves correctly. The program tested is a simple Fibonacci sequence with the following code:
        

            \begin{lstlisting}[language={[Sharp]C}]
int main(int argc, const char * argv[]) {
    int x, x_old, x_new, t, i;
    
    x = 1;
    x_old = 0;
    t = 14;
    
    for (i = 0; i < t; i++) {
        x_new = x + x_old;
        x_old = x;
        x = x_new;
    }
    return 0;
}
            \end{lstlisting}

        To compile the \texttt{C} code the site\footnote{\url{https://bellard.org/jslinux/} } is used. They have fully implemented a RISC-V CPU, which can be run in the browser. Choosing 64-bit console version we make a new file with the Fibonacci code within. The code can then be compiled with the gcc compiler making sure it only uses the \texttt{RV64I} instruction set. If this is not done 16-bit instructions will get used, which is currently not supported in this project. The following command is used for the compilation
        \begin{lstlisting}[language={[Sharp]C}]
gcc -c -march=rv64i -mabi=lp64 YourProgram.c
        \end{lstlisting}
        The compiled file can be read using
        \begin{lstlisting}[language={[Sharp]C}]
objdump -D hello.o | less
        \end{lstlisting} 
        which will look like the following
        \begin{lstlisting}[language={[Sharp]C}]
...
0000000000000000 <main>:
0:   fc010113                addi    sp,sp,-64
4:   02813c23                sd      s0,56(sp)
8:   04010413                addi    s0,sp,64
c:   00050793                mv      a5,a0
10:   fcb43023                sd      a1,-64(s0)
14:   fcf42623                sw      a5,-52(s0)
18:   00100793                li      a5,1
1c:   fef42623                sw      a5,-20(s0)
20:   fe042423                sw      zero,-24(s0)
24:   00e00793                li      a5,14
28:   fef42023                sw      a5,-32(s0)
2c:   fe042223                sw      zero,-28(s0)
30:   0300006f                j       60 <.L2>

0000000000000034 <.L3>:
34:   fec42703                lw      a4,-20(s0)
38:   fe842783                lw      a5,-24(s0)
3c:   00f707bb                addw    a5,a4,a5
...
        \end{lstlisting} 
        The leftmost column indicates the base address for the instruction, the second column is the hex number for the instruction, the third and fourth column is the instruction name and values given to the instruction respectively (the names may not seem familiar, this is due to pseodo instruction support in assembler, which we have not covered).
        
        Finally the hex values are converted to a binary file (remembering to add a zero instruction to the end) that can be read by the CPU and executed. Since the program is automatically compiled it is not trivial to check if the program got executed correctly. Therefore the compiled code has to be read carefully to figure out where in the data memory variables are stored and again see if they are updated correctly on every clock cycle. 
        
        The Fibonacci sequence returned with the correct results, this indicates that the RISC-V implementation behaves correctly.
        
        
    \subsection{VHDL and Synthesis}
        Information for this chapter was provided graciously by the help of Carl-Johannes Johnsen due to time constrains.
        Throughout this project we have carefully made sure that the C\scalerel*{\#}{X} simulation matches the generated VHDL testbench. The generated VHDL can then be given to vendor synthesis tools, which is used to implement the VHDL code on an FPGA.
        This work has been done by Carl to get the performance numbers for my RISC-V implementation. The board that was used was the \texttt{TUL PYNQ-Z2 board}\footnote{\url{http://www.tul.com.tw/ProductsPYNQ-Z2.html}}. 
        
        The speed at which the implementation was run were 100 MHz. The timing analyses showed a slack of 1.985 ns, which means that theoretically the processor could be run at 124 MHz (100 MHz corresponds to a clock cycle of 10 ns, removing the slack we can get down to about 8 ns per clock cycle, which corresponds to 124 Mhz, $10[ns]-1.985[ns]=8.015[ns]$). 
        
        Compared to the PicoRV32 implementation in \cite{8760205}, which ran at 115 Mhz, the speed at which my implementation ran seems reasonable. Furthermore the utilization of FPGA resources i.e  the number of LUTs (Look up tables) and FFs (Flip flops) used in my implementation was 4586 and 2903 respectively. This is about double as many as the PicoRV32 implementation (2123 LUTs and 1509 FFs), which is also reasonable, since their implementation is 32-bit and mine is 64-bit.
        
        The thermal design power estimated by vivaldo is 0.19 W.
        
        
        
        
        
    